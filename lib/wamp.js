// Generated by CoffeeScript 1.7.1
(function() {
  var MAX_ID, MESSAGE_TYPES, TRANSPORT_TYPES, WampClient, WampPeer, WampRouter, createWampRouter, defer, e, events, genId, isValidURI, net, randomNum, test, util, ws,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  events = require('events');

  util = require('util');

  net = require('net');

  ws = require('./ws');

  defer = require('./promises').defer;

  try {
    defer = require('./promises.litcoffee').defer;
  } catch (_error) {
    e = _error;
    defer = require('./promises').defer;
  }

  MESSAGE_TYPES = {
    HELLO: 1,
    WELCOME: 2,
    ABORT: 3,
    CHALLENGE: 4,
    AUTHENTICATE: 5,
    GOODBYE: 6,
    HEARTBEAT: 7,
    ERROR: 8,
    PUBLISH: 16,
    PUBLISHED: 17,
    SUBSCRIBE: 32,
    SUBSCRIBED: 33,
    UNSUBSCRIBE: 34,
    UNSUBSCRIBED: 35,
    EVENT: 36,
    CALL: 48,
    CANCEL: 49,
    RESULT: 50,
    REGISTER: 64,
    REGISTERED: 65,
    UNREGISTER: 66,
    UNREGISTERED: 67,
    INVOCATION: 68,
    INTERRUPT: 69,
    YIELD: 70
  };

  TRANSPORT_TYPES = {
    DIRECT: 1,
    WEBSOCKET: 2,
    UNIXSOCKET: 3
  };

  MAX_ID = Math.pow(2, 53);

  isValidURI = function(uri_string) {
    return !!uri_string.match(/^(([0-9a-z_]{2,}\.)|\.)*([0-9a-z_]{2,})?$/);
  };

  randomNum = function(len) {
    var n;
    return parseInt(((function() {
      var _i, _results;
      _results = [];
      for (n = _i = 1; 1 <= len ? _i <= len : _i >= len; n = 1 <= len ? ++_i : --_i) {
        _results.push((Math.floor(Math.random() * 10)).toString());
      }
      return _results;
    })()).join(''));
  };

  genId = function() {
    return randomNum(15);
  };


  /*
  class WampSession extends events.EventEmitter
    constructor: (@id, options) ->
      @_options = options or {}
      for key, val of @_options
        @[key] = val
      @nextId = 1
   */

  WampPeer = (function(_super) {
    "Peer at one end of Wamp Session. Involves acting as a session itself, as well";
    __extends(WampPeer, _super);

    function WampPeer(parent, transport, roles, options) {
      this.parent = parent;
      this.transport = transport;
      this.roles = roles;
      this.processMessage = __bind(this.processMessage, this);
      this.sendMessage = __bind(this.sendMessage, this);
      this.cleanUp = __bind(this.cleanUp, this);
      this.setOptions = __bind(this.setOptions, this);
      this.isOpen = true;
      this.transport.on('close', (function(_this) {
        return function(code) {
          _this.isOpen = false;
          _this.cleanUp();
          return console.log("Closing WampPeer due to transport closed.");
        };
      })(this));
      this.id = null;
      this.nextId = 1;
      this.setOptions(options);
    }

    WampPeer.prototype.setOptions = function(options) {
      var key, val, _ref, _results;
      this._options = options || {};
      _ref = this._options;
      _results = [];
      for (key in _ref) {
        val = _ref[key];
        _results.push(this[key] = val);
      }
      return _results;
    };

    WampPeer.prototype.cleanUp = function() {
      var index, invocation, invocations, key, proc, registered, session, sessions, subscription, subscriptions, topic, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _results;
      registered = (_ref = this.parent.realms) != null ? _ref[this.realm].registered_procedures : void 0;
      if (registered) {
        for (index = _i = 0, _len = registered.length; _i < _len; index = ++_i) {
          proc = registered[index];
          try {
            if (proc.sessionId === this.id) {
              this.parent.realms[this.realm].registered_procedures.splice(index, 1);
            }
          } catch (_error) {
            e = _error;
            console.log("ERROR: " + e.message);
          }
        }
      }
      invocations = (_ref1 = this.parent.realms) != null ? _ref1[this.realm].invocations : void 0;
      if (invocations) {
        for (index = _j = 0, _len1 = invocations.length; _j < _len1; index = ++_j) {
          invocation = invocations[index];
          try {
            if (invocation.sessionId === this.id) {
              this.parent.realms[this.realm].invocations.splice(index, 1);
            }
          } catch (_error) {
            e = _error;
            console.log("ERROR: " + e.message);
          }
        }
      }
      subscriptions = (_ref2 = this.parent.realms) != null ? _ref2[this.realm].subscriptions : void 0;
      if (subscriptions) {
        for (key in subscriptions) {
          topic = subscriptions[key];
          try {
            for (index = _k = 0, _len2 = topic.length; _k < _len2; index = ++_k) {
              subscription = topic[index];
              if (subscription.sessionId === this.id) {
                topic.splice(index, 1);
              }
            }
          } catch (_error) {
            e = _error;
            console.log("ERROR: " + e.message);
          }
        }
      }
      sessions = (_ref3 = this.parent.realms) != null ? _ref3[this.realm].sessions : void 0;
      if (sessions) {
        _results = [];
        for (index = _l = 0, _len3 = sessions.length; _l < _len3; index = ++_l) {
          session = sessions[index];
          try {
            if (session.id === this.id) {
              this.parent.realms[this.realm].sessions.splice(index, 1);
              break;
            } else {
              _results.push(void 0);
            }
          } catch (_error) {
            e = _error;
            _results.push(console.log("ERROR: " + e.message));
          }
        }
        return _results;
      }
    };

    WampPeer.prototype.sendMessage = function(message) {

      /*
      if @parent.constructor.name is "WampClient"
        console.log @parent.constructor.name, "sends a message:", JSON.stringify(message)
        console.log "Open condition is:", @isOpen
        console.log "WebSocket state is: %s", @transport.readyState
       */
      if (this.isOpen) {
        return this.transport.send(message);
      }
    };

    WampPeer.prototype.processMessage = function(message) {
      var ArgumentsKwDict, ArgumentsList, Details, KwArguments, OptionsDict, ProcedureUri, PublicationId, RegistrationId, RequestId, SubscriptionId, TopicUri, args, arr, callee_session, callee_sessionId, caller_session, caller_sessionId, code, details, index, invocation, invocation_message, key, kwArgs, msgArray, pendingCall, proc, procedure, publication, realm, registered_procedure, registration, registrationId, resp, result, result_message, session, sid, subscription, suscription, topic, _base, _i, _j, _k, _l, _len, _len1, _len10, _len11, _len12, _len13, _len14, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _len9, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref2, _ref20, _ref21, _ref22, _ref23, _ref24, _ref25, _ref26, _ref27, _ref28, _ref29, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _results, _results1, _results2, _results3, _results4, _results5, _s, _t, _u, _v, _w;
      if (!this.isOpen) {
        return;
      }
      arr = JSON.parse(message);
      code = arr[0];
      if (code !== MESSAGE_TYPES.HELLO && code !== MESSAGE_TYPES.WELCOME) {
        if (!this.id) {
          return;
        }
      }
      switch (code) {
        case MESSAGE_TYPES.HELLO:
          console.log("Router received HELLO message");
          _ref = arr.slice(1), realm = _ref[0], details = _ref[1];
          this.id = this.parent.nextSessionId;
          this.realm = realm;
          this.setOptions(details);
          if (!(realm in this.parent.realms)) {
            this.parent.realms[realm] = {
              sessions: [],
              registered_procedures: [],
              invocations: [],
              subscriptions: {}
            };
          }
          this.parent.realms[realm].sessions.push(this);
          console.log("@realms[" + realm + "].sessions.length: %d", this.parent.realms[realm].sessions.length);
          this.sendMessage(JSON.stringify([
            MESSAGE_TYPES.WELCOME, this.parent.nextSessionId, {
              roles: this.roles
            }
          ]));
          console.log("Router sent WELCOME message to " + this.parent.nextSessionId);
          return this.parent.nextSessionId += 1;
        case MESSAGE_TYPES.WELCOME:
          console.log("Client Received Welcome Message");
          _ref1 = arr.slice(1), sid = _ref1[0], details = _ref1[1];
          this.id = sid;
          this.routerRoles = details;
          this.realm = this.parent.realm;
          this.parent.subscriptions = this.subscriptions = [];
          this.parent.publications = this.publications = [];
          this.parent.registrations = this.registrations = [];
          this.parent.calls = this.calls = [];
          return typeof (_base = this.parent).onopen === "function" ? _base.onopen({
            id: this.id,
            realm: this.realm,
            roles: this.roles,
            routerRoles: this.routerRoles,
            subscriptions: this.subscriptions,
            registrations: this.registrations,
            calls: this.calls
          }) : void 0;
        case MESSAGE_TYPES.ABORT:
          return console.log("Received Abort Message");
        case MESSAGE_TYPES.CHALLENGE:
          return console.log("Received Challenge Message");
        case MESSAGE_TYPES.AUTHENTICATE:
          return console.log("Received Authenticate Message");
        case MESSAGE_TYPES.GOODBYE:
          console.log("Received GoodBye Message");
          this.sendMessage(message);
          this.cleanUp();
          return this.transport.close();
        case MESSAGE_TYPES.HEARTBEAT:
          return console.log("Received HeartBeat Message");
        case MESSAGE_TYPES.PUBLISH:
          _ref2 = arr.slice(1), RequestId = _ref2[0], OptionsDict = _ref2[1], TopicUri = _ref2[2], ArgumentsList = _ref2[3], ArgumentsKwDict = _ref2[4];
          PublicationId = this.nextId;
          this.nextId += 1;
          topic = this.parent.realms[this.realm].subscriptions[TopicUri];
          if (topic) {
            for (_i = 0, _len = topic.length; _i < _len; _i++) {
              suscription = topic[_i];
              _ref3 = this.parent.realms[this.realm].sessions;
              for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
                session = _ref3[_j];
                if (session.id === suscription.sessionId) {
                  msgArray = [MESSAGE_TYPES.EVENT, suscription.SubscriptionId, PublicationId, OptionsDict];
                  if (ArgumentsList) {
                    msgArray.push(ArgumentsList);
                  }
                  if (ArgumentsKwDict) {
                    msgArray.push(ArgumentsKwDict);
                  }
                  session.sendMessage(JSON.stringify(msgArray));
                  break;
                }
              }
            }
          }
          if (OptionsDict.acknowledge) {
            return this.sendMessage(JSON.stringify([MESSAGE_TYPES.PUBLISHED, RequestId, PublicationId]));
          }
          break;
        case MESSAGE_TYPES.PUBLISHED:
          _ref4 = arr.slice(1), RequestId = _ref4[0], PublicationId = _ref4[1];
          console.log("Received Published Message for Request Id: " + RequestId + " with Publication Id: " + PublicationId);
          _ref5 = this.parent.publications;
          _results = [];
          for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
            publication = _ref5[_k];
            if (publication.RequestId === RequestId) {
              publication.PublicatioId = PublicatioId;
              console.log("Updated publication " + RequestId + " with publication id: " + PublicationId);
              break;
            } else {
              _results.push(void 0);
            }
          }
          return _results;
          break;
        case MESSAGE_TYPES.SUBSCRIBE:
          console.log("Received subscribe message from session " + this.id);
          _ref6 = arr.slice(1), RequestId = _ref6[0], OptionsDict = _ref6[1], TopicUri = _ref6[2];
          SubscriptionId = this.nextId;
          this.nextId += 1;
          if (!this.parent.realms[this.realm].subscriptions[TopicUri]) {
            this.parent.realms[this.realm].subscriptions[TopicUri] = [];
          }
          this.parent.realms[this.realm].subscriptions[TopicUri].push({
            sessionId: this.id,
            SubscriptionId: SubscriptionId,
            OptionsDict: OptionsDict
          });
          resp = [MESSAGE_TYPES.SUBSCRIBED, RequestId, SubscriptionId];
          this.sendMessage(JSON.stringify(resp));
          return console.log("Registered subscription for " + TopicUri + " in realm " + this.realm);
        case MESSAGE_TYPES.SUBSCRIBED:
          _ref7 = arr.slice(1), RequestId = _ref7[0], SubscriptionId = _ref7[1];
          console.log("Received Subscribed Message for Request Id: " + RequestId + " with Subscription Id: " + SubscriptionId);
          _ref8 = this.parent.subscriptions;
          _results1 = [];
          for (_l = 0, _len3 = _ref8.length; _l < _len3; _l++) {
            subscription = _ref8[_l];
            if (subscription.RequestId === RequestId) {
              subscription.SubscriptionId = SubscriptionId;
              console.log("Updated subscription " + subscription.topic + " with subscription id: " + SubscriptionId);
              break;
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
          break;
        case MESSAGE_TYPES.UNSUBSCRIBE:
          _ref9 = arr.slice(1), RequestId = _ref9[0], SubscriptionId = _ref9[1];
          console.log("Received unsubscribe message from session " + this.id + " with requestId: " + RequestId + " and subscriptionId: " + SubscriptionId);
          _ref10 = this.parent.realms[this.realm].subscriptions;
          for (key in _ref10) {
            topic = _ref10[key];
            for (index = _m = 0, _len4 = topic.length; _m < _len4; index = ++_m) {
              subscription = topic[index];
              if ((subscription.SubscriptionId === SubscriptionId) && (subscription.sessionId === this.id)) {
                console.log("Found subscription to erase at index " + index + ". Going to do it for request: " + RequestId);
                topic.splice(index, 1);
                return this.sendMessage(JSON.stringify([MESSAGE_TYPES.UNSUBSCRIBED, RequestId]));
              }
            }
          }
          console.log("Did not find a subscription to erase. Sending error message: 'wamp.error.no_such_subscription'");
          return this.sendMessage(JSON.stringify([MESSAGE_TYPES.ERROR, MESSAGE_TYPES.UNSUBSCRIBE, RequestId, {}, "wamp.error.no_such_subscription"]));
        case MESSAGE_TYPES.UNSUBSCRIBED:
          return console.log("Received Unsubscribed Message");
        case MESSAGE_TYPES.EVENT:
          _ref11 = arr.slice(1), SubscriptionId = _ref11[0], PublicationId = _ref11[1], Details = _ref11[2], args = _ref11[3], kwArgs = _ref11[4];
          console.log("Received Event Message for subscription id: " + SubscriptionId + " with the following args: %j", args);
          _ref12 = this.subscriptions;
          _results2 = [];
          for (_n = 0, _len5 = _ref12.length; _n < _len5; _n++) {
            subscription = _ref12[_n];
            if (subscription.SubscriptionId === SubscriptionId) {
              subscription.handler(args, kwArgs);
              break;
            } else {
              _results2.push(void 0);
            }
          }
          return _results2;
          break;
        case MESSAGE_TYPES.CALL:
          _ref13 = arr.slice(1), RequestId = _ref13[0], OptionsDict = _ref13[1], ProcedureUri = _ref13[2], ArgumentsList = _ref13[3], ArgumentsKwDict = _ref13[4];
          _ref14 = this.parent.realms[this.realm].registered_procedures;
          for (_o = 0, _len6 = _ref14.length; _o < _len6; _o++) {
            proc = _ref14[_o];
            if (proc.ProcedureUri === ProcedureUri) {
              callee_sessionId = proc.sessionId;
              registrationId = proc.RegistrationId;
              _ref15 = this.parent.realms[this.realm].sessions;
              for (_p = 0, _len7 = _ref15.length; _p < _len7; _p++) {
                session = _ref15[_p];
                if (session.id === callee_sessionId) {
                  callee_session = session;
                  invocation_message = [MESSAGE_TYPES.INVOCATION, RequestId, registrationId, OptionsDict, ArgumentsList || [], ArgumentsKwDict || {}];
                  this.parent.realms[this.realm].invocations.push({
                    sessionId: this.id,
                    requestId: RequestId
                  });
                  return callee_session.sendMessage(JSON.stringify(invocation_message));
                }
              }
            }
          }
          break;
        case MESSAGE_TYPES.CANCEL:
          return console.log("Received Cancel Message");
        case MESSAGE_TYPES.RESULT:
          _ref16 = arr.slice(1), RequestId = _ref16[0], OptionsDict = _ref16[1], ArgumentsList = _ref16[2], KwArguments = _ref16[3];
          console.log("Client received Result Message for request id: " + RequestId + ". Results are: %j , %j", ArgumentsList, KwArguments);
          _ref17 = this.calls;
          _results3 = [];
          for (index = _q = 0, _len8 = _ref17.length; _q < _len8; index = ++_q) {
            pendingCall = _ref17[index];
            if (pendingCall.RequestId === RequestId) {
              if (Object.keys(KwArguments).length !== 0) {
                ArgumentsList(push(KwArguments));
              }
              if ((_ref18 = pendingCall.deferred) != null) {
                _ref18.resolve(ArgumentsList);
              }
              this.calls.splice(index, 1);
              break;
            } else {
              _results3.push(void 0);
            }
          }
          return _results3;
          break;
        case MESSAGE_TYPES.REGISTER:
          console.log("Router received register message from session " + this.id);
          _ref19 = arr.slice(1), RequestId = _ref19[0], OptionsDict = _ref19[1], ProcedureUri = _ref19[2];
          _ref20 = this.parent.realms[this.realm].registered_procedures;
          for (_r = 0, _len9 = _ref20.length; _r < _len9; _r++) {
            procedure = _ref20[_r];
            if (procedure.ProcedureUri === ProcedureUri) {
              console.log("ERROR: procedure " + ProcedureUri + " already registered.");
              return this.sendMessage(JSON.stringify([MESSAGE_TYPES.ERROR, MESSAGE_TYPES.REGISTER, RequestId, {}, 'wamp.error.procedure_already_exists']));
            }
          }
          RegistrationId = this.nextId;
          this.nextId += 1;
          this.parent.realms[this.realm].registered_procedures.push({
            sessionId: this.id,
            RegistrationId: RegistrationId,
            OptionsDict: OptionsDict,
            ProcedureUri: ProcedureUri
          });
          resp = [MESSAGE_TYPES.REGISTERED, RequestId, RegistrationId];
          this.sendMessage(JSON.stringify(resp));
          return console.log("Router registered procedure " + ProcedureUri + " in realm " + this.realm);
        case MESSAGE_TYPES.REGISTERED:
          _ref21 = arr.slice(1), RequestId = _ref21[0], RegistrationId = _ref21[1];
          console.log("Client received Registered Message for RequestId: %s - RegistrationId: %s", RequestId, RegistrationId);
          _ref22 = this.parent.registrations;
          _results4 = [];
          for (_s = 0, _len10 = _ref22.length; _s < _len10; _s++) {
            registered_procedure = _ref22[_s];
            if (registered_procedure.RequestId === RequestId) {
              registered_procedure.RegistrationId = RegistrationId;
              console.log("Updated registered procedure " + registered_procedure.uri + " with registration id: " + RegistrationId);
              break;
            } else {
              _results4.push(void 0);
            }
          }
          return _results4;
          break;
        case MESSAGE_TYPES.UNREGISTER:
          console.log("Received Unregister Message");
          _ref23 = arr.slice(1), RequestId = _ref23[0], RegistrationId = _ref23[1];
          _ref24 = this.parent.realms[this.realm].registered_procedures;
          for (index = _t = 0, _len11 = _ref24.length; _t < _len11; index = ++_t) {
            procedure = _ref24[index];
            if (procedure.RegistrationId === RegistrationId) {
              this.parent.realms[this.realm].registered_procedures.splice(index, 1);
              return this.sendMessage(JSON.stringify([MESSAGE_TYPES.UNREGISTERED, RequestId]));
            }
          }
          return this.sendMessage(JSON.stringify([MESSAGE_TYPES.ERROR, MESSAGE_TYPES.UNREGISTER, RequestId, {}, 'wamp.error.no_such_registration']));
        case MESSAGE_TYPES.UNREGISTERED:
          RequestId = arr.slice(1)[0];
          return console.log("Received Unregistered Message for RequestId: %s", RequestId);
        case MESSAGE_TYPES.INVOCATION:
          _ref25 = arr.slice(1), RequestId = _ref25[0], RegistrationId = _ref25[1], OptionsDict = _ref25[2], ArgumentsList = _ref25[3], KwArguments = _ref25[4];
          console.log("Client received Invocation Message for registration id: " + RegistrationId + " with arguments: %j", ArgumentsList);
          _ref26 = this.parent.registrations;
          _results5 = [];
          for (index = _u = 0, _len12 = _ref26.length; _u < _len12; index = ++_u) {
            registration = _ref26[index];
            if (registration.RegistrationId === RegistrationId) {
              result = registration.fn.apply(null, ArgumentsList, KwArguments);
              this.sendMessage(JSON.stringify([MESSAGE_TYPES.YIELD, RequestId, OptionsDict, [result]]));
              break;
            } else {
              _results5.push(void 0);
            }
          }
          return _results5;
          break;
        case MESSAGE_TYPES.INTERRUPT:
          return console.log("Client received Interrupt Message");
        case MESSAGE_TYPES.YIELD:
          console.log("Router received Yield Message from session " + this.id);
          _ref27 = arr.slice(1), RequestId = _ref27[0], OptionsDict = _ref27[1], ArgumentsList = _ref27[2], ArgumentsKwDict = _ref27[3];
          _ref28 = this.parent.realms[this.realm].invocations;
          for (_v = 0, _len13 = _ref28.length; _v < _len13; _v++) {
            invocation = _ref28[_v];
            if (invocation.requestId === RequestId) {
              caller_sessionId = invocation.sessionId;
              _ref29 = this.parent.realms[this.realm].sessions;
              for (_w = 0, _len14 = _ref29.length; _w < _len14; _w++) {
                session = _ref29[_w];
                if (session.id === caller_sessionId) {
                  caller_session = session;
                  result_message = [MESSAGE_TYPES.RESULT, RequestId, OptionsDict, ArgumentsList || [], ArgumentsKwDict || {}];
                  return caller_session.sendMessage(JSON.stringify(result_message));
                }
              }
            }
          }
          break;
        default:
          return console.log("Unknown code received.");
      }
    };

    return WampPeer;

  })(events.EventEmitter);

  WampClient = (function(_super) {
    __extends(WampClient, _super);

    function WampClient(options) {
      this.publish = __bind(this.publish, this);
      this.call = __bind(this.call, this);
      this.register = __bind(this.register, this);
      this.connect = __bind(this.connect, this);
      var key, value;
      if ((!(options != null ? options.url : void 0)) || (!(options != null ? options.realm : void 0))) {
        throw new Error("Must provide a url and a realm to connect to");
      }
      for (key in options) {
        value = options[key];
        this[key] = value;
      }
      this.roles = this.roles || {
        subscriber: {},
        publisher: {},
        callee: {},
        caller: {}
      };
    }

    WampClient.prototype.connect = function() {
      this.websocket = new ws.WebSocketClientConnection(this.url);
      return this.websocket.on('open', (function(_this) {
        return function() {
          _this.peer = new WampPeer(_this, _this.websocket, _this.roles);
          _this.websocket.on('data', function(opcode, data) {
            return _this.peer.processMessage(data);
          });
          _this.peer.sendMessage(JSON.stringify([MESSAGE_TYPES.HELLO, _this.realm, _this.roles]));
          return true;
        };
      })(this));
    };

    WampClient.prototype.register = function(uri, fn, options) {
      var reqId;
      reqId = this.peer.nextId;
      this.peer.nextId += 1;
      this.registrations.push({
        RequestId: reqId,
        uri: uri,
        fn: fn
      });
      return this.peer.sendMessage(JSON.stringify([MESSAGE_TYPES.REGISTER, reqId, options || {}, uri]));
    };

    WampClient.prototype.call = function(procUri, args, kwArgs, options) {
      var callData, deferred, reqId;
      if (args == null) {
        args = [];
      }
      if (kwArgs == null) {
        kwArgs = {};
      }
      if (options == null) {
        options = {};
      }
      reqId = this.peer.nextId;
      this.peer.nextId += 1;
      deferred = defer();
      callData = {
        RequestId: reqId,
        uri: procUri,
        args: args,
        kwArgs: kwArgs,
        options: options,
        deferred: deferred
      };
      this.peer.calls.push(callData);
      this.peer.sendMessage(JSON.stringify([MESSAGE_TYPES.CALL, reqId, options, procUri, args, kwArgs]));
      return deferred.promise();
    };

    WampClient.prototype.subscribe = function(topic, handler, options) {
      var deferred, reqId, subscriptionData;
      if (options == null) {
        options = {};
      }
      reqId = this.peer.nextId;
      this.peer.nextId += 1;
      deferred = defer();
      subscriptionData = {
        RequestId: reqId,
        topic: topic,
        handler: handler,
        options: options,
        deferred: deferred
      };
      this.peer.subscriptions.push(subscriptionData);
      this.peer.sendMessage(JSON.stringify([MESSAGE_TYPES.SUBSCRIBE, reqId, options, topic]));
      return deferred.promise();
    };

    WampClient.prototype.publish = function(topic, args, kwArgs, options) {
      var deferred, publicationData, reqId;
      if (args == null) {
        args = [];
      }
      if (kwArgs == null) {
        kwArgs = {};
      }
      if (options == null) {
        options = {};
      }
      reqId = this.peer.nextId;
      this.peer.nextId += 1;
      deferred = defer();
      publicationData = {
        RequestId: reqId,
        topic: topic,
        args: args,
        kwArgs: kwArgs,
        options: options,
        deferred: deferred
      };
      this.peer.publications.push(publicationData);
      this.peer.sendMessage(JSON.stringify([MESSAGE_TYPES.PUBLISH, reqId, options, topic, args, kwArgs]));
      return deferred.promise();
    };

    return WampClient;

  })(events.EventEmitter);

  WampRouter = (function(_super) {
    __extends(WampRouter, _super);

    WampRouter.prototype._webSocketHandler = function(websocket) {
      websocket.peer = new WampPeer(this, websocket, this.roles);
      websocket.on('open', (function(_this) {
        return function() {
          return console.log("WebSocket opened");
        };
      })(this));
      websocket.on('data', (function(_this) {
        return function(opcode, data) {
          return websocket.peer.processMessage(data);
        };
      })(this));
      return websocket.on('close', (function(_this) {
        return function(code, reason) {
          return console.log("Websocket closed. Close event data:\n Code: " + (code || 'no data') + " - Reason: " + (reason || 'no data'));
        };
      })(this));
    };

    function WampRouter(options) {
      this.listen = __bind(this.listen, this);
      this._webSocketHandler = __bind(this._webSocketHandler, this);
      this._options = options || {};
      this.roles = this._options.roles || {
        broker: {},
        dealer: {}
      };
      this.nextSessionId = genId();
      this.realms = {};
      this.webSocketServer = ws.createWebSocketServer(this._webSocketHandler);
    }

    WampRouter.prototype.listen = function(port, host, route) {
      if (host == null) {
        host = '0.0.0.0';
      }
      if (route == null) {
        route = '/wamp';
      }
      return this.webSocketServer.listen(port, host, route);
    };

    return WampRouter;

  })(events.EventEmitter);

  createWampRouter = function() {
    return new WampRouter;
  };

  test = function() {
    var wampRouter;
    wampRouter = createWampRouter();
    wampRouter.listen(8000, '0.0.0.0', '/');
    return console.log("WAMP Router listening on port 8000");
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = {
      MESSAGE_TYPES: MESSAGE_TYPES,
      TRANSPORT_TYPES: TRANSPORT_TYPES,
      WampPeer: WampPeer,
      WampClient: WampClient,
      WampRouter: WampRouter,
      createWampRouter: createWampRouter
    };
  }

  if (!(typeof module !== "undefined" && module !== null ? module.parent : void 0)) {
    test();
  }

}).call(this);
